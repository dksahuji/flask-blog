== TIME STAMPS of CODE and COMMANDS==
on server
	create EC2 with ssh https and http 
	ssh -i ~/Downloads/dksahu.pem ubuntu@3.109.186.244
	apt update && apt upgrade
	hostnamectl set-hostname flask-server
	hostname
	vim /etc/hosts
		12.0.0.1 localhost
		3.109.186.244 flask-server
	adduser dksahu
	sudo adduser dksahu --disabled-password
	adduser dksahu sudo
	sudo usermod -aG sudo dksahu
	sudo su - dksahu
	sudo vim /etc/ssh/sshd_config
		add to end of file.
		Match User dksahu
      		PasswordAuthentication yes
    sudo service ssh reload
	mkdir .shh
	logout and login to server
on local machine
	ssh-keygen -b 4096 (empty passwrd)
	scp ~/.ssh/id_rsa.pub dksahu@ip:~/.ssh/authorized_keys
on server
	sudo chmod 700 ~/.ssh/
	sudo chmod 600 ~/.ssh/*
	sudo vim /etc/ssh/sshd_config
		PermitRootLogin no
		PasswordAuthentication no (hacker cant brute force passwrd because we are using ssh=keys)
	sudo systemctl restart sshd
	sudo apt install ufw (uncomplicated firewall)
	sudo ufw default allow outgoing 
	sudo ufw default deny incoming
	sudo ufw allow ssh
	sudo ufw allow 5000
	sudo ufw enable
	sudo ufw status
	git clone (if available)
on local
	29:41 - `pip freeze > requirements.txt` - and move the text into Flask_Blog folder
	30:35 - `scp -r Desktop/Flask_Blog coreyms@45.33.123.214:~/` - where we copy Flask_Blog from personal machine to Linode
ON SERVER
	31:50 - `sudo apt install python3-pip` 
	32:12 - `sudo apt install python3-venv`
	32:44 - `python3 -m venv Flask_Blog/venv`
	33:19 - `source venv/bin/activate` - in our Flask_Blog dir we activate our venv
	33:50 - `pip install -r requirements.txt` - we install our pip packages into our venv
	37:40 - `sudo touch /etc/config.json` & `sudo nano /etc/config.json` - where we now store our environment variables inside a file instead of the system 
	40:22 - `sudo nano flaskblog/config.py` - add the following code 
		`import json`
		`with open('/etc/config.json') as config_file:
			config = json.load(config_file)`
	41:50 - we are still in config.py and replace `os.environ.get` with `config.get`
	43:35 - `export FLASK_APP=run.py` - where we assign the environment variable FLASK_APP to the module
	43:55 - `flask run --host=0.0.0.0` -  we run a local dev server on the linode
	48:26 - `sudo apt install nginx` static webserver
	48:53 - `pip install gunicorn` python handled by gunicorn
	50:02 - `sudo rm /etc/nginx/sites-enabled/default` - we remove nginx default config
	50:20 - `sudo nano /etc/nginx/sites-enabled/flaskblog` -  new nginx config solely for our app. Add the code from Corey's snippets. Remember: gunicorn is running on port 8000, nginx is running on port 80
		server {
				listen 80;
				server_name ip;

				location /static {
						alias /home/dksahu/Flask_blog/flaskblog/static;
				}

				location / {
						proxy_pass http://localhost:8000;
						include /etc/nginx/proxy_params;
						proxy_redirect off;
				}
		}
	54:27 - `sudo ufw allow http/tcp` &	`sudo ufw delete allow 5000` & `sudo ufw enable` 
	55:00 - `sudo systemctl restart nginx` - restart nginx server
	56:25 - access your URL/static/main.css. This proves that nginx server is serving static content and that it cannot serve the dynamic content because Gunicorn is not running yet.
	58:02 - `nproc --all` - to find out how many cores on this machine
	58:35 - `gunicorn -w 3 run:app` - now that gunicorn is running, we access our main site and this proves that nginx is passing HTTP requests to gunicorn
	1:00:23 - `sudo apt install supervisor` - this software (written in python!) will run Gunicorn in the background
	1:00:50 - `sudo nano /etc/supervisor/conf.d/flaskblog.conf` - create a supervisor config file referring to flaskblog package, and Gunicorn. Add corey's snippets
		[program:flaskblog]
		directory=/home/dksahu/flask_blog
		command=/home/dksahu/flaskblog/venv/bin/gunicorn -w 3 run:app
		user=dksahu
		autostart=true
		autorestart=true
		stopasgroup=true
		killasgroup=true
		stderr_logfile=/var/log/flaskblog/flaskblog.err.log
		stdout_logfile=/var/log/flaskblog/flaskblog.out.log

	1:04:10 - note that we point supervisor to (yet uncreated) log files located:
		`/var/log/flaskblog/flaskblog.err.log` &
		`/var/log/flaskblog/flaskblog.out.log`
	1:05:03 - `sudo mkdir -p /var/log/flaskblog` 
	1:05:22 - `sudo touch /var/log/flaskblog/flaskblog.err.log` & `sudo touch /var/log/flaskblog/flaskblog.out.log` - where we now create our log files
	1:05:42 - `sudo supervisorctl reload` - where we restart supervisor
	1:07:40 - `sudo nano /etc/nginx/nginx.conf` - where we access general config file for nginx
	1:07:54 - `client_max_body_size 5M;` - add this code in the config file to increase upload limit from 2MB to 5MB
	1:08:30 - `sudo systemctl restart nginx`

Your site is now in production! :D

ENABLE  SSL/TLS certificate
	http not using SSL certificates
	https://letsencrypt.org/getting-started/
	sudo apt-get update
	sudo snap install core; sudo snap refresh core
	sudo apt-get remove certbot
	sudo snap install --classic certbot
	sudo apt-get update
	sudo apt-get install python-cert-bot-nginx

	vim /etc/nginx/sites-enabled/flaskblog
		set server name as domain name
		server_name www.curiousmlmind.com


	sudo certbot --nginx (add email address)
	
	sudo nginx -t (errors)

	sudo ufw allow https

	sudo systemctl restart nginx

	sudo certbot renew --dry- (simulate certificate renewal, not real)

	SETUP cron jobs every month to renew certificate
		sudo crontab -e
		choose editor
			"30 4 1 * * sudo certbot renew --quiet"




todo
use postgres database
www redirect to non wwww version
deploy to service like heroku


aws elastic beanstalk - service to deploy web applications easily
	application.py
	flask object should also be application
	.ebextensions
		python.config
			option_settings:
				"aws:elasticbeanstalk:container:python":
					WSGIPath: application:application
					

